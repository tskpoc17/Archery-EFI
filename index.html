<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archery EFI Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #targetCanvas { border-radius: 50%; cursor: crosshair; background: #fdfdfd; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8">
    <div class="max-w-5xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-8 text-red-600">射箭箭群 EFI 評估系統</h1>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
            <div class="bg-white p-6 rounded-xl shadow-md">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">參數設置</h2>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium">S (靶面分數範圍):</label>
                        <input type="number" id="paramS" value="10" class="w-full border p-2 rounded">
                    </div>
                    <div>
                        <label class="block text-sm font-medium">D (靶面直徑 cm):</label>
                        <input type="number" id="paramD" value="80" class="w-full border p-2 rounded">
                    </div>
                    <div>
                        <label class="block text-sm font-medium">K (距離修正係數):</label>
                        <input type="number" id="paramK" value="1" step="0.1" class="w-full border p-2 rounded">
                    </div>
                    <button onclick="resetAll()" class="w-full bg-gray-500 text-white py-2 rounded hover:bg-gray-600 transition">清空數據</button>
                </div>
                
                <div class="mt-8">
                    <h2 class="text-xl font-semibold mb-2 border-b pb-2">數據統計</h2>
                    <p>著箭數: <span id="arrowCount">0</span></p>
                    <div id="results" class="mt-4 space-y-2 hidden">
                        <div class="p-3 bg-red-50 rounded border border-red-200">
                            <p class="font-bold text-red-700">水平 EFI (X): <span id="efix">0</span></p>
                            <p class="font-bold text-red-700">垂直 EFI (Y): <span id="efiy">0</span></p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="md:col-span-2 flex flex-col items-center">
                <canvas id="targetCanvas" width="500" height="500"></canvas>
                <p class="mt-4 text-gray-500 text-sm">※ 點擊靶面位置標記箭點，系統將以靶心為 (0,0)</p>
                
                <div id="suggestionBox" class="mt-6 w-full bg-blue-50 p-6 rounded-xl border border-blue-200 hidden">
                    <h2 class="text-xl font-bold text-blue-800 mb-2">瞄準器調整建議</h2>
                    <p id="suggestionText" class="text-lg text-blue-700 font-medium"></p>
                </div>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('targetCanvas');
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    let arrows = [];

    // 初始化畫靶
    function drawTarget() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const colors = ['#ffffff', '#ffffff', '#000000', '#000000', '#00bfff', '#00bfff', '#ff0000', '#ff0000', '#ffff00', '#ffff00'];
        const ringWidth = canvas.width / 20;
        
        for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, (10 - i) * ringWidth, 0, Math.PI * 2);
            ctx.fillStyle = colors[i];
            ctx.fill();
            ctx.strokeStyle = '#ccc';
            ctx.stroke();
        }
        
        // 畫中心線
        ctx.beginPath();
        ctx.moveTo(centerX, 0); ctx.lineTo(centerX, canvas.height);
        ctx.moveTo(0, centerY); ctx.lineTo(canvas.width, centerY);
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.stroke();

        // 畫點
        arrows.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.px, p.py, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.stroke();
        });
    }

    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        
        // 轉換為實際座標 (以中心為0, 比例縮放)
        const D = parseFloat(document.getElementById('paramD').value);
        const scale = D / canvas.width;
        const x = (px - centerX) * scale;
        const y = (centerY - py) * scale; // Y軸向上為正

        arrows.push({ x, y, px, py });
        updateAnalysis();
        drawTarget();
    });

    function calculateEFI(values, S, D, K) {
        if (values.length < 2) return 0;
        
        const n = values.length;
        const mean = values.reduce((a, b) => a + b, 0) / n;
        
        const rightGroup = values.filter(v => v >= mean);
        const leftGroup = values.filter(v => v < mean);
        
        if (rightGroup.length === 0 || leftGroup.length === 0) return 1;

        const meanR = rightGroup.reduce((a, b) => a + b, 0) / rightGroup.length;
        const meanL = leftGroup.reduce((a, b) => a + b, 0) / leftGroup.length;
        
        const deltaMeanR = Math.abs(meanR - mean);
        const deltaMeanL = Math.abs(meanL - mean);
        
        const madR = rightGroup.reduce((a, b) => a + Math.abs(b - mean), 0) / rightGroup.length;
        const madL = leftGroup.reduce((a, b) => a + Math.abs(b - mean), 0) / leftGroup.length;
        
        const nr = rightGroup.length;
        const nl = leftGroup.length;

        const numerator = D - (K * deltaMeanR) - (K * deltaMeanL) - (K * (madR * nr + madL * nl) / (nr + nl));
        const efi = S * (numerator / D) + 1;
        
        return efi.toFixed(3);
    }

    function updateAnalysis() {
        const S = parseFloat(document.getElementById('paramS').value);
        const D = parseFloat(document.getElementById('paramD').value);
        const K = parseFloat(document.getElementById('paramK').value);

        document.getElementById('arrowCount').innerText = arrows.length;

        if (arrows.length >= 2) {
            const efiX = calculateEFI(arrows.map(a => a.x), S, D, K);
            const efiY = calculateEFI(arrows.map(a => a.y), S, D, K);

            document.getElementById('efix').innerText = efiX;
            document.getElementById('efiy').innerText = efiY;
            document.getElementById('results').classList.remove('hidden');
            
            // 瞄準器建議 (假設跟隨箭頭走: 箭偏右，瞄準器往右調)
            const avgX = arrows.reduce((a, b) => a + b.x, 0) / arrows.length;
            const avgY = arrows.reduce((a, b) => a + b.y, 0) / arrows.length;
            
            let suggestX = avgX > 0.5 ? `瞄準器向【右】調 ${Math.abs(avgX).toFixed(1)} cm` : (avgX < -0.5 ? `瞄準器向【左】調 ${Math.abs(avgX).toFixed(1)} cm` : "水平不需調整");
            let suggestY = avgY > 0.5 ? `瞄準器向【上】調 ${Math.abs(avgY).toFixed(1)} cm` : (avgY < -0.5 ? `瞄準器向【下】調 ${Math.abs(avgY).toFixed(1)} cm` : "垂直不需調整");
            
            document.getElementById('suggestionText').innerHTML = `${suggestX}<br>${suggestY}`;
            document.getElementById('suggestionBox').classList.remove('hidden');
        }
    }

    function resetAll() {
        arrows = [];
        drawTarget();
        document.getElementById('results').classList.add('hidden');
        document.getElementById('suggestionBox').classList.add('hidden');
        document.getElementById('arrowCount').innerText = "0";
    }

    drawTarget();
</script>
    <script>
(function() {
    /**
     * 功能一：獨立雙軸座標紀錄表
     * 說明：動態在頁面上插入一個區塊來顯示座標紀錄
     */
    function initCoordinateTablePlugin() {
        // 1. 尋找插入點 (放在瞄準建議區塊的下方)
        const container = document.querySelector('.md\\:col-span-2.flex.flex-col');
        if (!container) return;

        // 2. 創建紀錄區塊的 HTML 結構
        const recordBox = document.createElement('div');
        recordBox.id = 'coordinateRecordBox';
        recordBox.className = 'mt-6 w-full bg-gray-50 p-6 rounded-xl border border-gray-200';
        recordBox.innerHTML = `
            <h2 class="text-xl font-bold text-gray-800 mb-4">獨立著箭座標紀錄 (CM)</h2>
            <div class="overflow-y-auto max-h-64">
                <table class="min-w-full text-sm text-left text-gray-500">
                    <thead class="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0">
                        <tr>
                            <th scope="col" class="px-4 py-2 rounded-tl-lg">#</th>
                            <th scope="col" class="px-4 py-2">X 軸 (水平)</th>
                            <th scope="col" class="px-4 py-2 rounded-tr-lg">Y 軸 (垂直)</th>
                        </tr>
                    </thead>
                    <tbody id="coordinateTableBody" class="bg-white divide-y divide-gray-100">
                        <tr><td colspan="3" class="px-4 py-2 text-center text-gray-400">尚無數據</td></tr>
                    </tbody>
                </table>
            </div>
        `;
        container.appendChild(recordBox);

        // 3. 定義更新表格的函數
        window.updatePluginTable = function() {
            const tbody = document.getElementById('coordinateTableBody');
            if (!tbody) return;

            // 讀取全域變數 'arrows' (來自原始腳本)
            if (typeof arrows === 'undefined' || arrows.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" class="px-4 py-2 text-center text-gray-400">尚無數據</td></tr>';
                return;
            }

            let htmlStr = '';
            arrows.forEach((arrow, index) => {
                // X 軸右正左負，Y 軸上正下負，保留兩位小數
                const displayX = (arrow.x >= 0 ? '+' : '') + arrow.x.toFixed(2);
                const displayY = (arrow.y >= 0 ? '+' : '') + arrow.y.toFixed(2);
                
                htmlStr += `
                    <tr class="hover:bg-gray-50 transition">
                        <td class="px-4 py-2 font-medium text-gray-900">${index + 1}</td>
                        <td class="px-4 py-2 font-mono ${arrow.x > 0 ? 'text-red-600' : (arrow.x < 0 ? 'text-blue-600' : '')}">${displayX}</td>
                        <td class="px-4 py-2 font-mono ${arrow.y > 0 ? 'text-red-600' : (arrow.y < 0 ? 'text-blue-600' : '')}">${displayY}</td>
                    </tr>
                `;
            });
            tbody.innerHTML = htmlStr;
            // 自動捲動到底部
            tbody.parentElement.scrollTop = tbody.parentElement.scrollHeight;
        }

        // 4. 監聽主畫布的點擊事件，在原始腳本執行後更新表格
        const mainCanvas = document.getElementById('targetCanvas');
        mainCanvas.addEventListener('click', () => {
            // 使用 setTimeout 確保在原始腳本的 click 事件處理完畢後才執行
            setTimeout(window.updatePluginTable, 50);
        });

        // 5. 監聽重置按鈕
        const resetBtn = document.querySelector('button[onclick="resetAll()"]');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                setTimeout(window.updatePluginTable, 50);
            });
        }
    }

    /**
     * 功能二：點擊區域放大鏡
     * 說明：在滑鼠按下瞄準時顯示放大鏡
     */
    function initMagnifierPlugin() {
        const mainCanvas = document.getElementById('targetCanvas');
        if (!mainCanvas) return;

        // 設定參數
        const ZOOM_LEVEL = 3; // 放大倍率
        const LOUPE_SIZE = 150; // 放大鏡直徑 (px)

        // 創建放大鏡 Canvas
        const loupe = document.createElement('canvas');
        loupe.width = LOUPE_SIZE;
        loupe.height = LOUPE_SIZE;
        loupe.style.position = 'fixed';
        loupe.style.borderRadius = '50%';
        loupe.style.border = '3px solid rgba(255, 0, 0, 0.5)';
        loupe.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
        loupe.style.pointerEvents = 'none'; // 讓滑鼠事件穿透放大鏡
        loupe.style.display = 'none';
        loupe.style.zIndex = '9999';
        loupe.style.backgroundColor = 'white';
        document.body.appendChild(loupe);

        const loupeCtx = loupe.getContext('2d');
        let isPanning = false;

        // 繪製放大鏡內容的核心函數
        function drawLoupe(clientX, clientY) {
            const rect = mainCanvas.getBoundingClientRect();
            // 計算滑鼠在 canvas 內的相對座標
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // 檢查是否超出畫布邊界
            if (x < 0 || y < 0 || x > mainCanvas.width || y > mainCanvas.height) {
                loupe.style.display = 'none';
                return;
            }
            loupe.style.display = 'block';

            // 設定放大鏡在螢幕上的位置 (稍微偏移以免擋住游標)
            loupe.style.left = (clientX + 20) + 'px';
            loupe.style.top = (clientY - LOUPE_SIZE / 2) + 'px';

            // 清空放大鏡
            loupeCtx.clearRect(0, 0, LOUPE_SIZE, LOUPE_SIZE);
            loupeCtx.save();

            // 創建圓形剪裁區域
            loupeCtx.beginPath();
            loupeCtx.arc(LOUPE_SIZE / 2, LOUPE_SIZE / 2, LOUPE_SIZE / 2, 0, Math.PI * 2);
            loupeCtx.clip();

            // --- 核心魔法：繪製放大內容 ---
            // 來源：主畫布 (mainCanvas)
            // 來源 X, Y：以滑鼠為中心，向左上偏移半個放大鏡的視野範圍
            // 來源寬高：放大鏡尺寸除以倍率
            // 目標 X, Y, 寬高：填滿整個放大鏡 Canvas
            
            const sourceX = x - (LOUPE_SIZE / 2 / ZOOM_LEVEL);
            const sourceY = y - (LOUPE_SIZE / 2 / ZOOM_LEVEL);
            const sourceSize = LOUPE_SIZE / ZOOM_LEVEL;
            
            // 填充背景色 (避免邊緣透明)
            loupeCtx.fillStyle = 'white';
            loupeCtx.fillRect(0, 0, LOUPE_SIZE, LOUPE_SIZE);

            // 從主畫布複製像素並放大
            loupeCtx.drawImage(
                mainCanvas, 
                sourceX, sourceY, sourceSize, sourceSize, // 來源矩形
                0, 0, LOUPE_SIZE, LOUPE_SIZE              // 目標矩形 (放大)
            );
            
            // 畫十字準心輔助瞄準
            loupeCtx.beginPath();
            loupeCtx.moveTo(LOUPE_SIZE/2, 0); loupeCtx.lineTo(LOUPE_SIZE/2, LOUPE_SIZE);
            loupeCtx.moveTo(0, LOUPE_SIZE/2); loupeCtx.lineTo(LOUPE_SIZE, LOUPE_SIZE/2);
            loupeCtx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
            loupeCtx.lineWidth = 1;
            loupeCtx.stroke();

            loupeCtx.restore();
        }

        // 註冊滑鼠事件
        // 1. 滑鼠按下：開始顯示放大鏡
        mainCanvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            drawLoupe(e.clientX, e.clientY);
        });

        // 2. 滑鼠移動：如果按著，持續更新放大鏡內容
        window.addEventListener('mousemove', (e) => {
            if (isPanning) {
                drawLoupe(e.clientX, e.clientY);
            }
        });

        // 3. 滑鼠放開：隱藏放大鏡 (這時會觸發原本的 click 事件進行標記)
        window.addEventListener('mouseup', () => {
            if (isPanning) {
                isPanning = false;
                loupe.style.display = 'none';
            }
        });
    }

    // 啟動外掛
    // 使用 setTimeout 確保 DOM 元素都已經存在
    setTimeout(() => {
        initCoordinateTablePlugin();
        initMagnifierPlugin();
    }, 500);

})();
</script>
</body>
</html>
